/*
 * @Description: Three.js 3D 工具类
 * @Author: 彭祥 (Email:245803627@qq.com)
 * @Date: 2019/11/14 17:15
 * @LastEditors: pengxiang
 * @LastEditTime: 2019/11/14 17:15
 */
import * as THREE from "three";
import { TWEEN } from 'three/examples/jsm/libs/tween.module.min';
import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader';
import {OrbitControls} from "three/examples/jsm/controls/OrbitControls";
import {CSS2DObject} from "three/examples/jsm/renderers/CSS2DRenderer";
import {AnimationUtils} from "three";


export * from './CollisionDetection';

/*
 * 添加摄像机动画
 * 参考 https://blog.csdn.net/lin5165352/article/details/85708690
 */
export function animateCamera(current1, target1, current2, target2) {
    TWEEN.removeAll();
    let tween = null;
    let positionVar = {
        x1: current1.x,
        y1: current1.y,
        z1: current1.z,
        x2: target1.x,
        y2: target1.y,
        z2: target1.z
    };
    //关闭控制器
    this.controls.enabled = false;
    tween = new TWEEN.Tween(positionVar)
        .to({
            x1: current2.x,
            y1: current2.y,
            z1: current2.z,
            x2: target2.x,
            y2: target2.y,
            z2: target2.z
        }, 1000)
        .easing(TWEEN.Easing.Quadratic.InOut);

    tween.onUpdate(function() {
        this.camera.position.x = positionVar.x1;
        this.camera.position.y = positionVar.y1;
        this.camera.position.z = positionVar.z1;
        this.controls.target.x = positionVar.x2;
        this.controls.target.y = positionVar.y2;
        this.controls.target.z = positionVar.z2;
        this.controls.update();
        this.console.log(positionVar);
    });

    tween.onComplete(function() {
        ///开启控制器
        this.controls.enabled = true;
    });

    tween.start();
}

/**
 * 根据传入的图片数组，返回对应的spriteMaterial数组
 * @param imgAry
 * @param fun
 */
export function getSpriteMatAry(imgAry, callback) {
    const ary = imgAry.map((item) => {
        const img = new THREE.TextureLoader().load(item);
        const mat = new THREE.SpriteMaterial( { map: img, transparent: true, } ); //alphaMap: img
        return mat;
    });
    callback(true, ary);
}

//************************************************模型相关操作 start*********************************************************//
export function addFBXs(scene, mData, callback) {
    const group = new THREE.Group();
    scene.add( group );
    group.name ='FBXGroup';
    // group.scale.set(0.1,0.1,0.1);

    const mNum = mData.length;
    let mIndex = 0;
    const loader = new FBXLoader();

    const onLoad=()=> {
        const item = mData[mIndex];

        // let pObj = this.scene;
        loader.setPath(item.path);
        loader.load( item.url, (object)=>{
            // pObj.add( object );
            // pObj.attach(object);
            console.log('Loading Model complete!');
            object.userData.nData = item;
            object.name = item.name;
            // object.visible = item.visible;
            // object.position.set(item.position.x, item.position.y, item.position.z);
            // object.scale.set(item.scale.x, item.scale.y, item.scale.z);
            // object.rotation.set(item.rotation.x, item.rotation.y, item.rotation.z);

            //必须先缩放，再加载到场景，不然多模型组合的时候，会出问题；
            callback('loaded', object);

            let pObj = group;
            if(item.parentObj.modelName && item.parentObj.objectName) {
                const modelObj = scene.getObjectByName(item.parentObj.modelName);
                pObj = modelObj.getObjectByName(item.parentObj.objectName);
                // pObj.rotation.set(0,0,0);
                // pObj = modelObj;
                pObj.attach(object);
                // addArrowAxis(pObj, 1000);
            }else{
                pObj.add( object );
            }

            // pObj.add( object );

            if(mIndex < mNum - 1){
                mIndex ++;
                onLoad();
            }
            else if(mIndex === mNum - 1){
                callback('completed', group);
            }

        }, (event)=>{
            // let nowProgress = ((event.loaded / event.total)*100).toFixed(0); //单个模型的加载进度
            // console.log('Loading Model file: ' + nowProgress + '%');
            const totalProgress = (((mIndex + event.loaded / event.total) / mNum)*100).toFixed(2); // 所有模型的加载总进度
            // console.log(totalProgress);
            callback('progress', totalProgress);

        }, (event)=>{
            console.error('There was an error loading: ' + event, item.name);
            callback('error');
        } );
    };

    onLoad();
}

/**
 * 队列加载模型
 * @param PMesh 模型的父容器
 * @param modelList 模型列表
 * @param fun 加载成功或者失败的返回值
 */
export function loadModelFiles(PMesh, modelList, callback) {
    if(!modelList){return false;}
    // const x2 = Array.prototype.slice.call(modelList); [].slice.call(modelList)
    let nModelList = Array.isArray(modelList) === true ? modelList : Array(modelList);
    const nModeNum = nModelList.length;
    let nModelIndex = 0;
    const loader = new FBXLoader();

    const modelObjAry = [];
    function onLoad() {
        const nModelData = nModelList[nModelIndex];
        const item = nModelData.attr || nModelData;
        loader.load( item.url, (object)=>{
            PMesh.add( object );
            modelObjAry.push(object);
            console.log('Loading Model complete!');
            object.name = item.mId;
            object.visible = JSON.parse(item.visible);
            object.receiveShadow = true;
            object.castShadow = true;

            // if (typeof callback === 'function') { callback(false, 'oneLoaded', item.mId); }
            if (typeof callback === 'function') { callback(false, 'oneLoaded', object); }

            if(nModelIndex < nModeNum - 1){
                nModelIndex ++;
                onLoad();
            }
            else if(nModelIndex === nModeNum - 1){
                if (typeof callback === 'function') { callback(true, 'Complete', modelObjAry); }
            }
        }, (event)=>{
            // let nowProgress = ((event.loaded / event.total)*100).toFixed(0); //单个模型的加载进度
            // console.log('Loading Model file: ' + nowProgress + '%');
            const totalProgress = (((nModelIndex + event.loaded / event.total) / nModeNum)*100).toFixed(2); // 所有模型的加载总进度
            // console.log(totalProgress);
            if (typeof callback === 'function') { callback(false, 'progress', totalProgress); }

        }, (event)=>{
            console.error('There was an error loading: ' + event, item.mId);
            if (typeof callback === 'function') { callback(false, 'error'); }
        } );
    }

    onLoad();
}

export function loadModelFile(PMesh, nModelData, callback) {
    const loader = new FBXLoader();
    const item = nModelData.attr || nModelData;
    loader.load( item.url, (object)=>{
        PMesh.add( object );
        console.log('Loading Model complete!');
        object.name = item.mId;
        object.visible = JSON.parse(item.visible);
        // object.receiveShadow = true;
        // object.castShadow = true;
        object.traverse( function ( child ) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        } );


        callback(true, 'Complete', object);

    }, (event)=>{
        let nowProgress = ((event.loaded / event.total)*100).toFixed(0); //单个模型的加载进度
        // console.log('Loading Model file: ' + nowProgress + '%');
        // console.log(totalProgress);
        callback(false, 'progress', nowProgress);

    }, (event)=>{
        console.error('There was an error loading: ' + event);
        callback(false, 'error');
    } );
}

/**
 * 给指定的模型添加贴图
 * @param rootObj 模型所在的跟容器，一般是scene
 * @param mapAry 模型贴图数组 [{pId[模型的父Obj的Name] mId[模型Obj的Name] map[贴图] aoMap[] normalMap[] roughnessMap[] metalnessMap[]}, ...]
 * @param envMapAry 环境贴图数组
 * @param callback 回调函数
 * @returns {boolean}
 */
export function addModelMap(rootObj, mapAry, envMapAry, callback) {
    if(!mapAry || mapAry.length <= 0) {callback(true); return false;}
    // let nMapIndex = 0;
    // const nMapNum = mapAry.length;
    const textureLoader = new THREE.TextureLoader();

    mapAry.forEach((item, i) => {
        if(item.attr.path){textureLoader.setPath(item.attr.path);}else{textureLoader.setPath('');}

        let map, aoMap, normalMap, roughnessMap, metalnessMap, emissiveMap, envMap, envMapIntensity;
        if(item.attr.map){map = textureLoader.load( item.attr.map );}
        if(item.attr.aoMap){aoMap = textureLoader.load( item.attr.aoMap );}
        if(item.attr.normalMap){normalMap = textureLoader.load( item.attr.normalMap );}
        if(item.attr.roughnessMap){roughnessMap = textureLoader.load( item.attr.roughnessMap );}
        if(item.attr.metalnessMap){metalnessMap = textureLoader.load( item.attr.metalnessMap );}
        if(item.attr.emissiveMap){emissiveMap = textureLoader.load(item.attr.emissiveMap);}
        if(item.attr.envMap){envMap = envMapAry[Number(item.attr.envMap) - 1];}
        if(item.attr.envMapIntensity){envMapIntensity = Number(item.attr.envMapIntensity);}
        // const mt = new THREE.MeshPhongMaterial({map:map, aoMap:aoMap, normalMap:normalMap, specularMap:specularMap,});//alphaMap: aoMap, transparent: true,emissive: 0xffffee,emissiveIntensity: 1,specular: 0x080808,shininess: 5, emissive: '0xffffff'
        // const mt = new THREE.MeshStandardMaterial({map:map, aoMap:aoMap, normalMap:normalMap, roughnessMap:roughnessMap, metalnessMap:metalnessMap,skinning: true, emissiveMap:emissiveMap, emissive:'#ffffff', emissiveIntensity:2,
        // });
        //opacity和transparent是一起使用的,transparent为true时，opacity才起作用
        //overdraw 渲染物体有缝隙时，将其设为true
        //side 决定了绘制那个面，还是两个面都进行绘制
        //材质的属性值更新时，需要将needsUpdate为TRUE
        const mt = new THREE.MeshStandardMaterial({skinning: true,
            // overdraw:true,
            // transparent:true,
            // blending: THREE.AdditiveBlending,
            // depthTest: true,
            // depthWrite: false,
            // envMap: rootObj.background,
            // needsUpdate: true,
            side: THREE.DoubleSide,
            // shadowSide: THREE.BackSide, //定义投影的面。
            // dithering: true,
        });

        if(map){mt.map = map;} //颜色贴图
        if(aoMap){mt.aoMap = aoMap;} //该纹理的红色通道用作环境遮挡贴图
        if(normalMap){mt.normalMap = normalMap;} //用于创建法线贴图的纹理。RGB值会影响每个像素片段的曲面法线，并更改颜色照亮的方式。法线贴图不会改变曲面的实际形状，只会改变光照。
        if(roughnessMap){mt.roughnessMap = roughnessMap;} //该纹理的绿色通道用于改变材质的粗糙度。
        if(metalnessMap){mt.metalnessMap = metalnessMap;} //该纹理的蓝色通道用于改变材质的金属度。
        if(emissiveMap){mt.emissiveMap = emissiveMap; mt.emissiveIntensity = 1;}
        if(envMap){// mt.envMap = rootObj.background;
            mt.envMap = envMap;
        }
        if(envMapIntensity){mt.envMapIntensity = envMapIntensity;}  //通过乘以环境贴图的颜色来缩放环境贴图的效果。
        mt.polygonOffset = true;
        mt.polygonOffsetFactor = 0;
        mt.polygonOffsetUnits = 1.0 + i;
        mt.needsUpdate = true;

        const pObj = rootObj.getObjectByName(item.attr.pId); if(!pObj){return false;}
        const nObj = pObj.getObjectByName(item.attr.mId); if(!nObj){return false;}
        // if(nObj instanceof THREE.SkinnedMesh) {return false;}
        nObj.material = mt;
    });

    callback(true);
}

export function getEnvMap(mapAry, callback) {
    let cubeTextureLoader = new THREE.CubeTextureLoader();
    // cubeTextureLoader.setPath( 'static/model/EnvMap/' );
    // //六张图片分别是朝前的（posz）、朝后的（negz）、朝上的（posy）、朝下的（negy）、朝右的（posx）和朝左的（negx）。
    // let cubeTexture = cubeTextureLoader.load( ['px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg'] );
    cubeTextureLoader.format = THREE.RGBAFormat;
    cubeTextureLoader.mapping = THREE.CubeReflectionMapping;
    cubeTextureLoader.encoding = THREE.sRGBEncoding;
    const ary = mapAry.map((item)=>{
        cubeTextureLoader.setPath(item.attr.path);
        //六张图片分别是朝前的（posz）、朝后的（negz）、朝上的（posy）、朝下的（negy）、朝右的（posx）和朝左的（negx）。
        let cubeTexture = cubeTextureLoader.load( [
            item.attr.px, item.attr.nx, item.attr.py, item.attr.ny, item.attr.pz, item.attr.nz
        ] );

        return cubeTexture;
    });
    callback(true, ary);
    // return ary;
}

/* 获取一个模型的所有Texture
 * @param allMapObj
 * @param callback
 * @returns {boolean}
 */
export function getModelTextures(allMapObj, callback) {
    if(!allMapObj || allMapObj.length <= 0) {callback(true); return false;}
    const textureLoader = new THREE.TextureLoader();
    const allTextureObj = {};
    for(let key in allMapObj){
        const mAry = allMapObj[key][0].item;

        const ary = mAry.map((item)=>{
            textureLoader.setPath(item.attr.path);
            const nMap = textureLoader.load(item.attr.map);
            // const nPath = item.attr.path + item.attr.map;
            // const nMap = textureLoader.load(nPath);
            // console.log(nPath);
            return nMap;
        });
        allTextureObj[key] = ary;
    }
    callback(true, allTextureObj);
}

export function addModelMat(rootObj, mapAry, allTextureObj, callback) {
    if(!mapAry || mapAry.length <= 0) {callback(true); return false;}

    mapAry.forEach((item, i) => {
        let map, aoMap, normalMap, roughnessMap, metalnessMap, emissiveMap, envMap, envMapIntensity;
        if(item.attr.map){map = allTextureObj.map[Number(item.attr.map) - 1];}
        if(item.attr.aoMap){aoMap = allTextureObj.aoMap[Number(item.attr.aoMap) - 1];}
        if(item.attr.normalMap){normalMap = allTextureObj.normalMap[Number(item.attr.normalMap) - 1];}
        if(item.attr.roughnessMap){roughnessMap = allTextureObj.roughnessMap[Number(item.attr.roughnessMap) - 1];}
        if(item.attr.metalnessMap){metalnessMap = allTextureObj.metalnessMap[Number(item.attr.metalnessMap) - 1];}
        if(item.attr.emissiveMap){emissiveMap = allTextureObj.emissiveMap[Number(item.attr.emissiveMap) - 1];}
        if(item.attr.envMap){envMap = allTextureObj.envMap[Number(item.attr.envMap) - 1];}
        if(item.attr.envMapIntensity){envMapIntensity = Number(item.attr.envMapIntensity);}
        // const mt = new THREE.MeshPhongMaterial({map:map, aoMap:aoMap, normalMap:normalMap, specularMap:specularMap,});//alphaMap: aoMap, transparent: true,emissive: 0xffffee,emissiveIntensity: 1,specular: 0x080808,shininess: 5, emissive: '0xffffff'
        // const mt = new THREE.MeshStandardMaterial({map:map, aoMap:aoMap, normalMap:normalMap, roughnessMap:roughnessMap, metalnessMap:metalnessMap,skinning: true, emissiveMap:emissiveMap, emissive:'#ffffff', emissiveIntensity:2,
        // });
        //opacity和transparent是一起使用的,transparent为true时，opacity才起作用
        //overdraw 渲染物体有缝隙时，将其设为true
        //side 决定了绘制那个面，还是两个面都进行绘制
        //材质的属性值更新时，需要将needsUpdate为TRUE
        const mt = new THREE.MeshStandardMaterial({skinning: true,
            // overdraw:true,
            // transparent:true,
            // blending: THREE.AdditiveBlending,
            // depthTest: true,
            // depthWrite: false,
            // envMap: rootObj.background,
            // needsUpdate: true,
            side: THREE.DoubleSide,
            // shadowSide: THREE.BackSide, //定义投影的面。
            // dithering: true,
        });

        if(map){mt.map = map;} //颜色贴图
        if(aoMap){mt.aoMap = aoMap;} //该纹理的红色通道用作环境遮挡贴图
        if(normalMap){mt.normalMap = normalMap;} //用于创建法线贴图的纹理。RGB值会影响每个像素片段的曲面法线，并更改颜色照亮的方式。法线贴图不会改变曲面的实际形状，只会改变光照。
        if(roughnessMap){mt.roughnessMap = roughnessMap;} //该纹理的绿色通道用于改变材质的粗糙度。
        if(metalnessMap){mt.metalnessMap = metalnessMap;} //该纹理的蓝色通道用于改变材质的金属度。
        if(emissiveMap){mt.emissiveMap = emissiveMap; mt.emissiveIntensity = 1;}
        if(envMap){// mt.envMap = rootObj.background;
            mt.envMap = envMap;
        }
        if(envMapIntensity){mt.envMapIntensity = envMapIntensity;}  //通过乘以环境贴图的颜色来缩放环境贴图的效果。
        // mt.polygonOffset = true;
        // mt.polygonOffsetFactor = 0;
        // mt.polygonOffsetUnits = 1.0 + i;
        mt.needsUpdate = true;

        const pObj = rootObj.getObjectByName(item.attr.pId); if(!pObj){return false;}
        const nObj = pObj.getObjectByName(item.attr.mId); if(!nObj){return false;}
        // if(nObj instanceof THREE.SkinnedMesh) {return false;}
        nObj.material = mt;
        // console.log('mat:' + i);
    });

    callback(true);
}

function promiseTest() {
    function taskA() {
        console.log("Task A");
        return "From Task A";
    }
    function taskB(value) {
        console.log(value);
        console.log("Task B");
        return "From Task B";
    }
    function onRejected(error) {
        console.log(error);
    }
    function finalTask(value) {
        console.log(value);
        console.log("Final Task");
    }
    let promise = Promise.resolve();
    promise
        .then(taskA)
        .then(taskB)
        .catch(onRejected)
        .then(finalTask);
}


function addEnvMap() {
    // let cubeTextureLoader = new THREE.CubeTextureLoader();
    // cubeTextureLoader.setPath( 'static/model/EnvMap/' );
    // //六张图片分别是朝前的（posz）、朝后的（negz）、朝上的（posy）、朝下的（negy）、朝右的（posx）和朝左的（negx）。
    // let cubeTexture = cubeTextureLoader.load( [
    //     'px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg'
    // ] );
    // cubeTextureLoader.format = THREE.RGBFormat;
    // cubeTextureLoader.mapping = THREE.CubeReflectionMapping;
    // cubeTextureLoader.encoding = THREE.sRGBEncoding;
    // mt.envMap = cubeTexture;
}

/* 获取 模型 纹理贴图 材质
 *
 */
export function getModelMapMt(data) {
    // const textureLoader = new THREE.TextureLoader();
    // textureLoader.setPath('static/model/texture/');
    // const map = textureLoader.load( 'XIAOJINGLINGtest_XIAOJINGLING_BaseColor.png');
    // const aoMap = textureLoader.load( '' );
    // const normalMap = textureLoader.load( 'XIAOJINGLINGtest_XIAOJINGLING_Normal.png' );
    // const roughnessMap = textureLoader.load( 'mXIAOJINGLINGtest_XIAOJINGLING_Roughness.png' );
    // const metalnessMap = textureLoader.load( 'XIAOJINGLINGtest_XIAOJINGLING_Metallic.png' );
    // const emissiveMap = textureLoader.load( "XIAOJINGLINGtest_XIAOJINGLING_Emissive.png" );

    // const mt = new THREE.MeshStandardMaterial({
    //     map:map,
    //     aoMap:aoMap,
    //     normalMap:normalMap,
    //     roughnessMap:roughnessMap,
    //     metalnessMap:metalnessMap,
    //     emissiveMap:emissiveMap,
    //     skinning: true,
    // });

    const textureLoader = new THREE.TextureLoader();
    const mt = new THREE.MeshStandardMaterial({skinning: true, });

    textureLoader.setPath(data.path);
    const mapsData = data.maps;
    const nMapsObj = {};
    for(let key in mapsData) {
        const item = mapsData[key];
        if(!item){continue;}
        // nMapsObj[key] = textureLoader.load(item);
        mt[key] = textureLoader.load(item);
    }

    return mt;
}


/*
 * 获取模型动画的当前帧
 * @param mixer
 * @param fps
 * @returns {number} frame
 */
export function getModelAnimationCurrentFrame(mixer, fps) {
    const animationTime = mixer.time;
    const FRAME_RATE = fps || 30;//fps
    const frameIndex = Math.floor(animationTime*FRAME_RATE);
    return frameIndex;
}
/* 播放模型动画
 * @param pObj 播放动画的模型的父容器obj
 * @param nObjId 当前动画模型mesh的name
 * @param gMixer 全局动画控制器
 * @param data [data='{parentId:che, id:zqcm, startFrame:0, endFrame:25}']
 * @param fun 回调的函数
 */
export function playModelAnimation(pObj, nObjId, data, callback) {
    const pMesh = pObj.getObjectByName(nObjId);
    if (!pMesh) { console.log(nObjId + '模型不存在!'); return false; }
    // const nMesh = pMesh.getObjectByName(nObj.id);
    // this.mixer = null;
    //如果当前模型没有动画，则发出完成指令
    if (!pMesh.animations) {
        console.log('此模型没有动画：', pMesh.name);
        callback(true, 'finished');
        return false;
    }

    //如果当前模型具有动画，则进行下面步骤
    let nStartFrame = Number(data.startFrame);
    let nEndFrame = Number(data.endFrame);
    const nName = pMesh.name + '_' + nStartFrame + '_' + nEndFrame + '_clip';
    nStartFrame = nStartFrame > 0 ? (nStartFrame - 1) : nStartFrame;
    nEndFrame = nEndFrame + 1;

    //如果要倒着播动画
    let nClip = null;
    // nClip = AnimationUtils.subclip(pMesh.animations[ 0 ], nName , Number(nObj.endFrame), Number(nObj.startFrame));
    //     // nClip.tracks.reverse();
    nClip = AnimationUtils.subclip(pMesh.animations[0], nName, nStartFrame, nEndFrame);
    let mixer = new THREE.AnimationMixer(pMesh);
    // this.mixer = mixer;
    // const action = mixer.clipAction( pMesh.animations[ 0 ] );
    const action = mixer.clipAction(nClip);
    action.reset();
    action.loop = data.loop ? THREE[data.loop] : THREE.LoopOnce ;
    action.clampWhenFinished = true;
    action.timeScale = data.timeScale ? data.timeScale : 1;

    mixer.addEventListener('loop', function (e) {
        console.log('帧动画循环回调：', e);
    });
    mixer.addEventListener('finished', function (e) {
        console.log('帧动画结束回调：', e, nClip.name);
        cancelAnimationFrame(nAnimationFrameId);
        // this.mixer = null;
        mixer = null;
        callback('finished');
        // mixer.uncacheClip(nClip);
    });

    const clock = new THREE.Clock();
    let delta = null;
    let nAnimationFrameId = null;
    function renderUpdateAnimation() {
        nAnimationFrameId = requestAnimationFrame(renderUpdateAnimation);
        delta = clock.getDelta();
        if (mixer) mixer.update(delta); //更新动画控制器
    }
    renderUpdateAnimation();

    action.play();
    return {action:action, mixer:mixer, currentFrame:data.startFrame, startFrame:data.startFrame, endFrame:data.endFrame};
}



//************************************************模型相关操作 end*********************************************************//

/* 设置摄像机视角位置
 * @param controls 当前控制器
 * @param camera   当前摄像机
 * @param mData    摄像机视角位置
 * @param mTarget  摄像机旋转的中心目标
 */
export function setCameraPosition(controls, camera, mData, mTarget) {
    if(!mData || !mTarget) {return false;}
    // camera.position.copy(data.position);
    camera.position.set(mData.position.x/100, mData.position.y/100, mData.position.z/100);
    camera.rotation.copy(mData.rotation);
    camera.up.copy(mData.up);
    // camera.fov = 45;
    camera.lookAt(mTarget.position.x, mTarget.position.y, mTarget.position.z);
    camera.updateProjectionMatrix();

    // controls.target.copy(nTarget.position);
}

/*
 * 添加摄像机控制器角度限制
 * @param nControls 当前的摄像机控制器（一般是OrbitControls）
 * @param data 角度限制相关数据 [data="2.3, 1.3, 1.5, 1.1, 36, 10"]
 * 如果空值，则取默认值；一共6个值，分别是水平旋转上限，水平旋转下限，垂直旋转上限，垂直旋转下限，最大向外移动焦距，最大向内移动焦距]
 */
export function setOrbitControlsAngleLimit(controls, data) {
    let origAngle = {maxX:Infinity, minX:-Infinity, maxY:Math.PI, minY:0, maxZ:Infinity, minZ:0};
    let nowAngle = {maxX:null, minX:null, maxY:null, minY:null, maxZ:null, minZ:null};

    if(isString(data) === true){
        const limitAngle = data.replace(/\s*/g,"").split(',');
        const ary = limitAngle.map((item) =>{ return Number(item)});
        nowAngle = {maxX:ary[0], minX:ary[1], maxY:ary[2], minY:ary[3], maxZ:ary[4], minZ:ary[5]};
    }else{
        // nowAngle = {maxX:data.maxX, minX:ary[1], maxY:ary[2], minY:ary[3], maxZ:ary[4], minZ:ary[5]};
        nowAngle = data;
    }

    controls.maxAzimuthAngle = nowAngle.maxX || origAngle.maxX; //水平旋转的角度的上限，范围是-Math.PI到Math.PI（或Infinity无限制）， 其默认值为Infinity
    controls.minAzimuthAngle = nowAngle.minX || origAngle.minX; //水平旋转的角度的下限，范围是-Math.PI到Math.PI（或-Infinity无限制）， 其默认值为-Infinity。

    controls.maxPolarAngle = nowAngle.maxY || origAngle.maxY;  //能够垂直旋转的角度的上限，范围是0到Math.PI，其默认值为Math.PI。
    controls.minPolarAngle = nowAngle.minY || origAngle.minY;  //能够垂直旋转的角度的下限，范围是0到Math.PI，其默认值为0。

    controls.maxDistance = nowAngle.maxZ || origAngle.maxZ;    //能够将相机向外移动多少（仅适用于PerspectiveCamera），其默认值为Infinity  控制的 最大距离
    controls.minDistance = nowAngle.minZ || origAngle.minZ;    //能够将相机向内移动多少（仅适用于PerspectiveCamera），其默认值为0。    控制的 最小距离
}

/* 获得当前OrbitControls摄像机控制的角度值
 * @param controls
 * @param camera
 * @returns {*[]}
 */
export function getOrbitControlsAngle(controls, camera) {
    const distance = camera.position.distanceTo( controls.target );
    const obj = [
        controls.getAzimuthalAngle(), //获得当前的水平旋转，单位为弧度。
        controls.getPolarAngle(),     //获得当前的垂直旋转，单位为弧度。
        distance,                     //获得相机内外移动距离（仅适用于PerspectiveCamera），单位为Float。
    ];
    // console.log('摄像机控制器：', obj[0], obj[1], obj[2] );
    // console.log('%c' + '摄像机控制器' + '%c => mousemove', 'color: #fff; background: #41b882; padding: 3px 4px;', 'color: #41b882; background: #fff;');
    console.log('%c' + '摄像机控制器' + '%c ' +'水平旋转 '+obj[0]+ ' || '+'垂直旋转 '+obj[1]+ ' || '+'内外移动 '+obj[2], 'color: #fff; background: #41b882; padding: 3px 4px;', 'color: #41b882; background: #fff;');
    return obj;
}

/* 获取当前鼠标点击点坐标（主要用于Pano）
 * @param event
 * @param camera
 * @param scene
 * @returns {Vector3}
 */
export function getMousePointPosition(event, camera, scene, isLog) {
    const mouseX = event.clientX;//鼠标单击坐标X
    const mouseY = event.clientY;//鼠标单击坐标Y

    // 屏幕坐标转标准设备坐标
    const x = ( mouseX / window.innerWidth ) * 2 - 1;
    const y = -( mouseY / window.innerHeight ) * 2 + 1;
    //标准设备坐标(z=0.5这个值并没有一个具体的说法)
    const stdVector = new THREE.Vector3(x, y, 0.5);

    // 通过unproject方法，可以将标准设备坐标转世界坐标
    const worldVector = stdVector.unproject(camera);
    // console.log('鼠标点3维坐标', worldVector);
    if(isLog !== false) {
        console.log('%c' + '鼠标点3维坐标' + '%c ' + '', 'color: #fff; background: #41b882; padding: 3px 4px;', 'color: #41b882; background: #fff;', worldVector);
    }
    return worldVector;
}

/*
 * 在场景或者mesh中添加箭头坐标轴（position:0,0,0）
 * @param scene
 */
export function addArrowAxis(mesh, length) {
    const len = length ? length : 10;
    //用于简单模拟3个坐标轴的对象.  红色代表 X 轴. 绿色代表 Y 轴. 蓝色代表 Z 轴. 可以放在场景原点，也可以放在mesh中间点；
    const axesHelper = new THREE.AxesHelper( len );
    mesh.add( axesHelper );

    //用于模拟方向的3维箭头对象.  给X Y Z 三个轴线添加正向箭头辅助
    // var dir = new THREE.Vector3( 1, 2, 0 );//normalize the direction vector (convert to vector of length 1)
    // dir.normalize(); //规格化方向向量(转换为长度为1的向量)
    const arrowX = new THREE.ArrowHelper( (new THREE.Vector3( 1, 0, 0 )).normalize(), new THREE.Vector3( 0, 0, 0 ), len, 0xff0000 );
    arrowX.name = 'arrowX';
    mesh.add( arrowX );
    const arrowY = new THREE.ArrowHelper( (new THREE.Vector3( 0, 1, 0 )).normalize(), new THREE.Vector3( 0, 0, 0 ), len, 0x00ff00 );
    arrowY.name = 'arrowY';
    mesh.add( arrowY );
    const arrowZ = new THREE.ArrowHelper( (new THREE.Vector3( 0, 0, 1 )).normalize(), new THREE.Vector3( 0, 0, 0 ), len, 0x0000ff );
    arrowZ.name = 'arrowZ';
    mesh.add( arrowZ );
}

/*
 * 添加 网格辅助线
 * @param mesh
 */
export function addGridHelper(pMesh, gridProps) {
    gridProps = {size:gridProps.size || 100, divisions:gridProps.divisions || 100, color1:gridProps.color1 ? gridProps.color1 : 0xffffff, color2:gridProps.color2 ? gridProps.color2 : 0x9c9c9c, opacity:gridProps.opacity || 0.2, transparent:gridProps.transparent || true};

    //坐标格辅助对象
    const grid = new THREE.GridHelper( gridProps.size, gridProps.divisions, gridProps.color1, gridProps.color2); //2000, 20, 0x000000, 0x000000 0x888888
    // grid.rotateOnAxis( new THREE.Vector3( 1, 0, 0 ), 90 * ( Math.PI / 180 ) ); // 辅助网格 设置 根据轴旋转，参考webgl_loader_amf, webgl_loader_bvh
    grid.position.set( 0, 0, 0 );
    grid.material.opacity = gridProps.opacity; // 辅助网格 设置 透明度具体值
    grid.material.transparent = gridProps.transparent; // 辅助网格 设置 开启透明度
    pMesh.add( grid );

    //网格之间的填充物
    const mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( gridProps.size, gridProps.size), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
    mesh.rotation.x = - Math.PI / 2;
    mesh.receiveShadow = true;
    pMesh.add( mesh );


    // const mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
    // mesh.rotation.x = - Math.PI / 2;
    // mesh.receiveShadow = true;
    // pMesh.add( mesh );

    // const grid = new THREE.GridHelper( 2000, 20, 0x000000, 0x000000 );
    // grid.material.opacity = 0.2;
    // grid.material.transparent = true;
    // pMesh.add( grid );
}

/*
 * 获取当前全景图场景角度（主要用于Pano）
 * @param lat 上下视角
 * @param lon 左右视角
 * @param fov 相机远近
 */
export function getPanoSceneAngle(lat, lon, fov) {
    console.log('当前Pano场景角度', lat, lon, fov)
}


const nConsole = {
    log: (color, label, value)=>{
        console.log('%c' + label + '%c ' + value, 'color: #fff; background: #41b882; padding: 3px 4px;', 'color: #41b882; background: #fff;')
    }
};



//判断对象是否是字符串
function isString(obj){
    return Object.prototype.toString.call(obj) === "[object String]";
}


/* CSS2D提示文字
 * @returns {CSS2DObject}
 */
export function addCSS2DTxtObj(pObj, textContent) {
    const txtDiv = document.createElement( 'div' );
    // txtDiv.className = '';
    txtDiv.textContent = textContent; //Earth
    txtDiv.style.position = 'absolute';
    txtDiv.style.color = "white";
    txtDiv.style.fontSize = "20px";
    txtDiv.style.pointerEvents = "none";
    txtDiv.style.margin = 0;
    txtDiv.style.borderRadius = "5px";
    txtDiv.style.marginTop = '-1em';
    txtDiv.style.padding = '2px 5px 2px 5px';
    txtDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.50)';
    // txtDiv.setAttribute("style", "color: white; padding: 4px; background: rgba(0, 0, 0, 0.5); line-height: 1; border-radius: 5px; transform-origin: left top;");
    const txtObj = new CSS2DObject( txtDiv );
    // txtObj.position.set( 17,-6.5,-4 );
    pObj.add( txtObj );

    return txtObj;
}

/*
 * 创建一个悬浮提示文字类
 */
export class CSS2DHoverTxt {
    constructor(pObj, textContent, visible) {
        this.init(pObj, textContent, visible);
    }
    init(pObj, textContent, visible) {
        const txtDiv = document.createElement( 'div' );
        txtDiv.className = 'CSS2DHoverTxt';
        txtDiv.textContent = textContent; //Earth
        txtDiv.style.position = 'absolute';
        txtDiv.style.color = "white";
        txtDiv.style.fontSize = "20px";
        txtDiv.style.pointerEvents = "none";
        txtDiv.style.margin = 0;
        txtDiv.style.borderRadius = "5px";
        txtDiv.style.marginTop = '-1em';
        txtDiv.style.padding = '2px 5px 2px 5px';
        txtDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.50)';
        // txtDiv.setAttribute("style", "color: white; padding: 4px; background: rgba(0, 0, 0, 0.5); line-height: 1; border-radius: 5px; transform-origin: left top;");
        const txtObj = new CSS2DObject( txtDiv );
        // txtObj.position.set( 17,-6.5,-4 );
        txtObj.visible = visible;
        pObj.add( txtObj );
        this.txtObj = txtObj;
    }
    add() {

    }
    setVisible(visible, textContent, position, event) {
        this.txtObj.visible = visible;
        this.txtObj.element.textContent = textContent;
        // this.hoverTxt.element.style.left = (oEvent.clientX + 20) + 'px';
        // this.hoverTxt.element.style.top  = (oEvent.clientY + 5) + 'px';
        // this.hoverTxt.position.set(oEvent.clientX, oEvent.clientY, 0);
        // this.hoverTxt.position.copy(target.position);
        // const nPosition = getMousePointPosition(oEvent, this.camera, this.scene);
        position = position ? position : {x:0, y:0, z:0};
        this.txtObj.position.set(position.x, position.y, position.z);
    }

}


/*
 * 添加辅助系统
 * @param nObj
 */
export function addAidSystem(nObj) {
    const {container, scene, camera, controls} = nObj;
    //性能监测
    // this.stats = new Stats();
    // this.container.appendChild(this.stats.dom);

    //网格平面
    addGridHelper(scene, {size:2000, divisions:20, color1:new THREE.Color(0x000000), color2:new THREE.Color(0x000000), opacity:0.2, transparent:true});
    //箭头-世界轴心线
    addArrowAxis(scene, 100);

    document.addEventListener( 'mousedown', (event)=>{
        // const x1 = that;
        getMousePointPosition(event, camera, scene);
        // getPanoSceneAngle(this.camera.lat, this.camera.lon, this.camera.fov);
        getOrbitControlsAngle(controls, camera);
    }, false );

    document.addEventListener( 'wheel', (event)=>{
        // const x1 = that;
        console.log(event.deltaY, camera.fov);
    }, false );
}


// export as namespace THREEx;
